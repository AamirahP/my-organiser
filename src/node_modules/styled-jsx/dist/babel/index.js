var require$$1 = require('path');
var require$$0 = require('fs');
var require$$0$1 = require('buffer');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var require$$1__default = /*#__PURE__*/_interopDefaultLegacy(require$$1);
var require$$0__default = /*#__PURE__*/_interopDefaultLegacy(require$$0);
var require$$0__default$1 = /*#__PURE__*/_interopDefaultLegacy(require$$0$1);

var lib$3 = {};

var lib$2 = {};

function _createForOfIteratorHelperLoose$k(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
Object.defineProperty(lib$2, "__esModule", {
    value: true
});
lib$2.declare = declare;
lib$2.declarePreset = void 0;
function declare(builder) {
    return function(api, options, dirname) {
        var _clonedApi2;
        var clonedApi;
        for(var _iterator = _createForOfIteratorHelperLoose$k(Object.keys(apiPolyfills)), _step; !(_step = _iterator()).done;){
            var name = _step.value;
            var _clonedApi;
            if (api[name]) continue;
            clonedApi = (_clonedApi = clonedApi) != null ? _clonedApi : copyApiObject(api);
            clonedApi[name] = apiPolyfills[name](clonedApi);
        }
        return builder((_clonedApi2 = clonedApi) != null ? _clonedApi2 : api, options || {}, dirname);
    };
}
var declarePreset = declare;
lib$2.declarePreset = declarePreset;
var apiPolyfills = {
    assertVersion: function(api) {
        return function(range) {
            throwVersionError(range, api.version);
        };
    },
    targets: function() {
        return function() {
            return {};
        };
    },
    assumption: function() {
        return function() {
            return undefined;
        };
    }
};
function copyApiObject(api) {
    var proto = null;
    if (typeof api.version === "string" && /^7\./.test(api.version)) {
        proto = Object.getPrototypeOf(api);
        if (proto && (!has$1(proto, "version") || !has$1(proto, "transform") || !has$1(proto, "template") || !has$1(proto, "types"))) {
            proto = null;
        }
    }
    return Object.assign({}, proto, api);
}
function has$1(obj, key) {
    return Object.prototype.hasOwnProperty.call(obj, key);
}
function throwVersionError(range, version) {
    if (typeof range === "number") {
        if (!Number.isInteger(range)) {
            throw new Error("Expected string or integer value.");
        }
        range = "^" + range + ".0.0-0";
    }
    if (typeof range !== "string") {
        throw new Error("Expected string or integer value.");
    }
    var limit = Error.stackTraceLimit;
    if (typeof limit === "number" && limit < 25) {
        Error.stackTraceLimit = 25;
    }
    var err;
    if (version.slice(0, 2) === "7.") {
        err = new Error('Requires Babel "^7.0.0-beta.41", but was loaded with "' + version + '". ' + "You'll need to update your @babel/core version.");
    } else {
        err = new Error('Requires Babel "' + range + '", but was loaded with "' + version + '". ' + "If you are sure you have a compatible version of @babel/core, " + "it is likely that something in your build process is loading the " + "wrong version. Inspect the stack trace of this error to look for " + 'the first entry that doesn\'t mention "@babel/core" or "babel-core" ' + "to see what is calling Babel.");
    }
    if (typeof limit === "number") {
        Error.stackTraceLimit = limit;
    }
    throw Object.assign(err, {
        code: "BABEL_VERSION_UNSUPPORTED",
        version: version,
        range: range
    });
}

Object.defineProperty(lib$3, "__esModule", {
    value: true
});
var default_1 = lib$3.default = void 0;
var _helperPluginUtils = lib$2;
var _default$5 = (0, _helperPluginUtils.declare)(function(api) {
    api.assertVersion(7);
    return {
        name: "syntax-jsx",
        manipulateOptions: function manipulateOptions(opts, parserOpts) {
            if (parserOpts.plugins.some(function(p) {
                return (Array.isArray(p) ? p[0] : p) === "typescript";
            })) {
                return;
            }
            parserOpts.plugins.push("jsx");
        }
    };
});
default_1 = lib$3.default = _default$5;

var lib$1 = {};

var isReactComponent$1 = {};

var buildMatchMemberExpression$1 = {};

var matchesPattern$1 = {};

var generated$4 = {};

var shallowEqual$1 = {};

function _createForOfIteratorHelperLoose$j(o, allowArrayLike) {
    var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"];
    if (it) return (it = it.call(o)).next.bind(it);
    if (Array.isArray(o) || (it = unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") {
        if (it) o = it;
        var i = 0;
        return function() {
            if (i >= o.length) return {
                done: true
            };
            return {
                done: false,
                value: o[i++]
            };
        };
    }
    throw new TypeError("Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
Object.defineProperty(shallowEqual$1, "__esModule", {
    value: true
});
shallowEqual$1.default = shallowEqual;
function shallowEqual(actual, expected) {
    var keys = Object.keys(expected);
    for(var _iterator = _createForOfIteratorHelperLoose$j(keys), _step; !(_step = _iterator()).done;){
        var key = _step.value;
        if (actual[key] !== expected[key]) {
            return false;
        }
    }
    return true;
}

Object.defineProperty(generated$4, "__esModule", {
    value: true
});
generated$4.isArrayExpression = isArrayExpression;
generated$4.isAssignmentExpression = isAssignmentExpression;
generated$4.isBinaryExpression = isBinaryExpression;
generated$4.isInterpreterDirective = isInterpreterDirective;
generated$4.isDirective = isDirective;
generated$4.isDirectiveLiteral = isDirectiveLiteral;
generated$4.isBlockStatement = isBlockStatement;
generated$4.isBreakStatement = isBreakStatement;
generated$4.isCallExpression = isCallExpression;
generated$4.isCatchClause = isCatchClause;
generated$4.isConditionalExpression = isConditionalExpression;
generated$4.isContinueStatement = isContinueStatement;
generated$4.isDebuggerStatement = isDebuggerStatement;
generated$4.isDoWhileStatement = isDoWhileStatement;
generated$4.isEmptyStatement = isEmptyStatement;
generated$4.isExpressionStatement = isExpressionStatement;
generated$4.isFile = isFile;
generated$4.isForInStatement = isForInStatement;
generated$4.isForStatement = isForStatement;
generated$4.isFunctionDeclaration = isFunctionDeclaration;
generated$4.isFunctionExpression = isFunctionExpression;
generated$4.isIdentifier = isIdentifier;
generated$4.isIfStatement = isIfStatement;
generated$4.isLabeledStatement = isLabeledStatement;
generated$4.isStringLiteral = isStringLiteral;
generated$4.isNumericLiteral = isNumericLiteral;
generated$4.isNullLiteral = isNullLiteral;
generated$4.isBooleanLiteral = isBooleanLiteral;
generated$4.isRegExpLiteral = isRegExpLiteral;
generated$4.isLogicalExpression = isLogicalExpression;
generated$4.isMemberExpression = isMemberExpression;
generated$4.isNewExpression = isNewExpression;
generated$4.isProgram = isProgram;
generated$4.isObjectExpression = isObjectExpression;
generated$4.isObjectMethod = isObjectMethod;
generated$4.isObjectProperty = isObjectProperty;
generated$4.isRestElement = isRestElement;
generated$4.isReturnStatement = isReturnStatement;
generated$4.isSequenceExpression = isSequenceExpression;
generated$4.isParenthesizedExpression = isParenthesizedExpression;
generated$4.isSwitchCase = isSwitchCase;
generated$4.isSwitchStatement = isSwitchStatement;
generated$4.isThisExpression = isThisExpression;
generated$4.isThrowStatement = isThrowStatement;
generated$4.isTryStatement = isTryStatement;
generated$4.isUnaryExpression = isUnaryExpression;
generated$4.isUpdateExpression = isUpdateExpression;
generated$4.isVariableDeclaration = isVariableDeclaration;
generated$4.isVariableDeclarator = isVariableDeclarator;
generated$4.isWhileStatement = isWhileStatement;
generated$4.isWithStatement = isWithStatement;
generated$4.isAssignmentPattern = isAssignmentPattern;
generated$4.isArrayPattern = isArrayPattern;
generated$4.isArrowFunctionExpression = isArrowFunctionExpression;
generated$4.isClassBody = isClassBody;
generated$4.isClassExpression = isClassExpression;
generated$4.isClassDeclaration = isClassDeclaration;
generated$4.isExportAllDeclaration = isExportAllDeclaration;
generated$4.isExportDefaultDeclaration = isExportDefaultDeclaration;
generated$4.isExportNamedDeclaration = isExportNamedDeclaration;
generated$4.isExportSpecifier = isExportSpecifier;
generated$4.isForOfStatement = isForOfStatement;
generated$4.isImportDeclaration = isImportDeclaration;
generated$4.isImportDefaultSpecifier = isImportDefaultSpecifier;
generated$4.isImportNamespaceSpecifier = isImportNamespaceSpecifier;
generated$4.isImportSpecifier = isImportSpecifier;
generated$4.isMetaProperty = isMetaProperty;
generated$4.isClassMethod = isClassMethod;
generated$4.isObjectPattern = isObjectPattern;
generated$4.isSpreadElement = isSpreadElement;
generated$4.isSuper = isSuper;
generated$4.isTaggedTemplateExpression = isTaggedTemplateExpression;
generated$4.isTemplateElement = isTemplateElement;
generated$4.isTemplateLiteral = isTemplateLiteral;
generated$4.isYieldExpression = isYieldExpression;
generated$4.isAwaitExpression = isAwaitExpression;
generated$4.isImport = isImport;
generated$4.isBigIntLiteral = isBigIntLiteral;
generated$4.isExportNamespaceSpecifier = isExportNamespaceSpecifier;
generated$4.isOptionalMemberExpression = isOptionalMemberExpression;
generated$4.isOptionalCallExpression = isOptionalCallExpression;
generated$4.isClassProperty = isClassProperty;
generated$4.isClassPrivateProperty = isClassPrivateProperty;
generated$4.isClassPrivateMethod = isClassPrivateMethod;
generated$4.isPrivateName = isPrivateName;
generated$4.isAnyTypeAnnotation = isAnyTypeAnnotation;
generated$4.isArrayTypeAnnotation = isArrayTypeAnnotation;
generated$4.isBooleanTypeAnnotation = isBooleanTypeAnnotation;
generated$4.isBooleanLiteralTypeAnnotation = isBooleanLiteralTypeAnnotation;
generated$4.isNullLiteralTypeAnnotation = isNullLiteralTypeAnnotation;
generated$4.isClassImplements = isClassImplements;
generated$4.isDeclareClass = isDeclareClass;
generated$4.isDeclareFunction = isDeclareFunction;
generated$4.isDeclareInterface = isDeclareInterface;
generated$4.isDeclareModule = isDeclareModule;
generated$4.isDeclareModuleExports = isDeclareModuleExports;
generated$4.isDeclareTypeAlias = isDeclareTypeAlias;
generated$4.isDeclareOpaqueType = isDeclareOpaqueType;
generated$4.isDeclareVariable = isDeclareVariable;
generated$4.isDeclareExportDeclaration = isDeclareExportDeclaration;
generated$4.isDeclareExportAllDeclaration = isDeclareExportAllDeclaration;
generated$4.isDeclaredPredicate = isDeclaredPredicate;
generated$4.isExistsTypeAnnotation = isExistsTypeAnnotation;
generated$4.isFunctionTypeAnnotation = isFunctionTypeAnnotation;
generated$4.isFunctionTypeParam = isFunctionTypeParam;
generated$4.isGenericTypeAnnotation = isGenericTypeAnnotation;
generated$4.isInferredPredicate = isInferredPredicate;
generated$4.isInterfaceExtends = isInterfaceExtends;
generated$4.isInterfaceDeclaration = isInterfaceDeclaration;
generated$4.isInterfaceTypeAnnotation = isInterfaceTypeAnnotation;
generated$4.isIntersectionTypeAnnotation = isIntersectionTypeAnnotation;
generated$4.isMixedTypeAnnotation = isMixedTypeAnnotation;
generated$4.isEmptyTypeAnnotation = isEmptyTypeAnnotation;
generated$4.isNullableTypeAnnotation = isNullableTypeAnnotation;
generated$4.isNumberLiteralTypeAnnotation = isNumberLiteralTypeAnnotation;
generated$4.isNumberTypeAnnotation = isNumberTypeAnnotation;
generated$4.isObjectTypeAnnotation = isObjectTypeAnnotation;
generated$4.isObjectTypeInternalSlot = isObjectTypeInternalSlot;
generated$4.isObjectTypeCallProperty = isObjectTypeCallProperty;
generated$4.isObjectTypeIndexer = isObjectTypeIndexer;
generated$4.isObjectTypeProperty = isOb